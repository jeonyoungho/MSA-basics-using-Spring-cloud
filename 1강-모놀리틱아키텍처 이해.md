# 1강-모놀리틱 아키텍처 이해

## 모놀리틱 아키텍처란?
#### 1) AWS가 없던 시절 E-commerce 스타트업을 시작한다고 가정해보자.

<img width="540" alt="스크린샷 2021-04-14 오후 5 15 30" src="https://user-images.githubusercontent.com/44339530/114677176-052be880-9d45-11eb-9e80-cea8412e7dfe.png"><br>

- 위의 그림처럼 개발자 1명은 개발한 코드를 톰캣에 의해 실행되고 프로그램의 상태는 DB에 저장될 것이다.<br>

#### 2) 만약 개발자를 추가로 영입하게 된다고 가정해보자.
<img width="555" alt="스크린샷 2021-04-14 오후 5 18 38" src="https://user-images.githubusercontent.com/44339530/114677628-74a1d800-9d45-11eb-9a35-4cba7a8f1185.png"><br>

- 만약 개발자가 3명이 된다면 다음 그림과 같이 형상 관리 툴을 통해 관리하며 DB는 공유할 것이다.

- 만약 상용 오픈할때 배포 스크립트를 작성하던가 톰캣 매니저를 통해 배포 할 것이다.

<img width="578" alt="스크린샷 2021-04-14 오후 5 21 00" src="https://user-images.githubusercontent.com/44339530/114677995-c9455300-9d45-11eb-8079-433a0e5f0857.png"><br>

- <b>위의 그림과 같이 배포를 진행하게 되면 무중단 배포가 불가능하게 된다.</b><br>

#### 3) 만약 서비스의 규모가 조금 늘어났다고 가정해보자.
<img width="580" alt="스크린샷 2021-04-14 오후 5 25 27" src="https://user-images.githubusercontent.com/44339530/114678639-686a4a80-9d46-11eb-9996-1aadccb8e7a4.png"><br>

- 톰캣을 한대 더 구입해서 로드밸런서(L4)를 통해 로드밸런싱을 구성할 것이다. 다음과 같은 구성을 HA(High Availavility: 높은 가용성을 지닌)구성이라 한다.
- 로드밸런싱에서 잠깐 톰캣을 빼고 톰캣을 중단 후 재배포 후 톰캣을 다시 시작하고 로드밸런싱에 다시 톰캣을 설정할 것이다.

#### 4) 만약 서비스가 흥행하여 트래픽이 기하급수적으로 늘어났다고 가정해보자.
<img width="578" alt="스크린샷 2021-04-14 오후 5 32 09" src="https://user-images.githubusercontent.com/44339530/114679674-589f3600-9d47-11eb-84f7-ecc1a9ce4058.png"><br>

- 톰캣 서버를 추가적으로 구입해서 LB에 일일이 설정을 해줄 것이다.

#### 5) 서비스가 대박이나서 신규채용을 진행 후 조직개편을 한다고 가정해보자.
<img width="574" alt="스크린샷 2021-04-14 오후 5 34 02" src="https://user-images.githubusercontent.com/44339530/114679933-9b610e00-9d47-11eb-8ff7-0ed036abeb36.png"><br>

- 상품팀, 주문팀으로 개편 후 그대로 단일 Repository 정책을 유지한다.
- <b>이때 심각하게 문제가 발생한다.</b>
    - 1)Branch에 Merge할 때 충돌이 발생(예전의 svn기준)
    - 2)QA를 어디까지 해야하는지 기준이 애매해짐 (정기배포일을 정해서 QA를 하게됨)
    - 3)각 팀마다 다른 일정이 있기에 배포 이슈가 생길 가능성이 커짐
    - 4)기타 등등

#### 6) 주문팀과 상품팀이 인프라에 요청을 해서 두 가지 서버군(도메인)으로 분리하게 된다고 가정해보자.
<img width="582" alt="스크린샷 2021-04-14 오후 5 46 58" src="https://user-images.githubusercontent.com/44339530/114681760-6a81d880-9d49-11eb-8ccf-7e46cec24e01.png"><br>

- <b>주문팀에서 상품정보를 갖고 올려하는데 도메인이 product에 있으니 갖고 올 수가 없는 문제점이 있음</b>
- Share라는 공통 코드들이 있는 레포지토리를 생성해서 두 팀이 공유하게 된다.
- <b>이렇게 되면 잘 될거 같지만 잘 되질 않는다. 왜냐하면 실제 개발은 공용 레포지토리에서 이뤄지기 때문이다. Order라는 레포지토리가 있음에도 Product팀에서도 필요할거같아서 Share에 개발하고 상품정보를 갖고 오는 무언가 있는데 그것도 Share에 존재할 가능성이 높기 때문이다.</b>
- 최종적으로 배포될 Share.jar를 두 팀이 공유하다보니 전체적인 sync를 맞춰야함. 그러다보니 정기배포일이 큰 업무의 비중을 차지하게 됨.
- snapshot이란 누군가가 업데이트를 하면 계속 업데이트 되는 버전임(고정된 버전이 아님)

#### 회사는 점점 더 성장하며 개발자가 150명 이상이 된다고 가정해보자.
- 회원팀, 상품팀, 주문팀, 정산팀, 셀러팀, 등등 추가적인 팀들이 생성될 것이다.
- DB는 보통 하나만 갖게 될 것이고 공통 레포지토리의 코드들은 수백만라인이 될 것이다.(소스 코드만 100MB이상)
- 공통 레포지토리에서 하니깐 복붙하는데 중복과 복잡도가 엄청 날 것이다.

## 콘웨이의 법칙(Conway's Law)
<img width="578" alt="스크린샷 2021-04-14 오후 5 51 28" src="https://user-images.githubusercontent.com/44339530/114682418-0ad7fd00-9d4a-11eb-94d8-e2c07846a078.png"><br>

- 하나의 share.jar 애플리케이션으로 뜨는게 모놀리틱인데 너무 많은 팀이 관여가 되있으니깐 팀들간의 과다한 소통이 발생할 것이고 크나큰 위험을 수반할 것이다.(뭔가 개발하고 배포해야 될때, 주문팀이 상품팀과 정산팀에도 물어봐야 하는 등)

## 모놀리틱 아키텍쳐 정리
<img width="579" alt="스크린샷 2021-04-14 오후 5 54 33" src="https://user-images.githubusercontent.com/44339530/114682879-79b55600-9d4a-11eb-9e78-bb2997a5abc7.png"><br>

- 구체적인 장단점은 위의 사진 참고
- 하나의 공통 코드들이 있어서 공통 코드를 임포트해서 하나의 애플리케이션을 띄우는 아키텍처
- 하나의 애플리케이션에 다양한 서비스들이 있기에 각 서비스를 담당하는 팀들과 지속적인 소통이 요구되며 장애의 위험성이 존재함
- 이러한 모놀리틱의 문제를 개편하기 위해 새로운 언어, 깔끔한 코드로 전면 재개편하거나 MSA플랫폼을 구현하여 기존 Legacy를 벗어나게 됨

#### 출처
- https://www.youtube.com/watch?v=D6drzNZWs-Y&list=PL9mhQYIlKEhdtYdxxZ6hZeb0va2Gm17A5&index=1
- https://freedeveloper.tistory.com/435?category=919480